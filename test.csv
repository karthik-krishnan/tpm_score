Developer workstation initial setup,Developer workstation setup drift,Developer workstation to production parity,Integrated Development Environment (IDE),New application starters,Production Debugging,Test Environments,Code Review Strategy,Continuous Integration,Code Standards,Static Analysis Tools,Local Builds,Build Stability,Failed Builds,Automated Unit Testing,Automated Integration Testing,Automated Contract Testing,Automated Functional Testing,Automated Acceptance Testing,Performance & Scale Testing [Capacity Testing],Performance & Scale Testing [Load Testing],Performance & Scale Testing [Stress Testing],Performance & Scale Testing [Soak Testing],Performance & Scale Testing [Spike Testing],Performance & Scale Testing [Volume Testing],Performance & Scale Testing [Chaos Testing],Manual Testing,Test Data Management,Refactoring,Packaging Format,Deployment Style,Business Continuity (Disaster Recovery),Deployment Frequency,Deployment Window,Deployment Moratorium,Deployment Target Host,Datastore Style,Application configuration,Feature Toggles,Release Notes,API Gateway,API Versioning,API Documentation,API Standards and Style Guides,Architecture Decisions,Architecture Conformance,Architectural Styles,Resilience Patterns [Circuit Breakers],Resilience Patterns [Client-side Load Balancers],Resilience Patterns [Service Discovery],Resilience Patterns [API Fallbacks],Resilience Patterns [Rate Limiting],Resilience Patterns [Throttling],Resilience Patterns [Bulkheads],Resilience Patterns [Timeouts],Resilience Patterns [Caching],Observability Patterns [Log Aggregation],Observability Patterns [Monitoring],Observability Patterns [Distributed Tracing],Observability Patterns [Health Checks],Observability Patterns [Alerting],Observability Patterns [Dashboards],Security Testing [Static Analysis Security Testing (SAST)],Security Testing [Dynamic  Analysis Security Testing (DAST)],Security Testing [Interactive  Analysis Security Testing (IAST)],Data at Rest Security,Data in Transit Security,Authentication & Authorization,Secrets Management
"Is clear, well documented and maintained up-to-date. Some portions of the setup are automated and result in identical workstation station state.",Is uncommon. Automation exists to get up-to-date with most if not all software. Developers can easily work on each others' workstations with almost no loss in productivity.,Developer workstations are able to simulate formal/production environments with the help of,"Developers are free to use an IDE of their choice. However, settings for static analysis, security analysis, build settings, etc. are shared formally.",Creating new applications is done using in-house tested extensions derived from standard scaffold creators. Maintaining dependencies and standards after the scaffold is created is left to individual teams.,Debugging production issues does not require special access to any systems. These systems make enough observability information to make debugging easy without exposing sensitive data.,"Teams are allowed and able to provision ephemeral test environments, but do not have the ability to generate the required test data to execute complex scenarios. Such environments are limited to testing ""simple"" scenarios.","Code reviews happen formally, most stylistic comments are taken care of using static analysis tools prior to a human review. Code review comments, however are not preserved for context.",Check-ins and CI happen on a short-lived private branch to satisfy a pull-request workflow. A branch-by-abstraction style is used to turn off incomplete work. Integration is truly continuous.,Code standards are provided and actively maintained. These standards are enforced as part of the build and will result in failures if rules are violated.,Static analysis tools are prescribed and actively maintained. The rules for these tools are enforced as part of the build and will result in failures if rules are violated.,"Local builds before check-in are encouraged, but take a long time to execute successfully. Furthermore, successful local builds still require monitoring the build after check-in because environmental issues are common.","The build process includes a good mix of unit, integration, functional and acceptance tests, and these tests are mostly green. Additional manual testing is required for scenarios not covered through automated testing.","Failed builds are not that common. But when failures do happen, other team members wait for the build to be fixed. Team members avoid checking in on top of a red build.","Unit tests are written, with some tests being written before production code and coverage being pretty high, but the practice is not trusted enough to yield consistent benefits.","Integration Testing is mostly used as an augment to unit testing with only a few tests being written against this class of tests. This provides a happy mix of the faster, less expensive unit tests vs. slower, more expensive integration tests","Contract tests are written by client teams and contributed to the producer teams. Client teams use these stubs for functional, acceptance and other expensive forms of testing. These tests when run successfully in the producer's build pipeline result in stubs that the producer team publishes for client teams to use. However, this practice is not common yet.","Automated functional testing is practiced by most teams, and there is a good level of maturity among the teams. However, functional testing does not take into account the amount of testing that may have happened at lower levels. A lot of the functional testing effort could be reduced if more attention was paid to coverage already achieved at lower levels of automated testing.","Automated acceptance testing is practiced by most teams, and there is a good level of maturity among the teams. However, acceptance testing does not take into account the amount of testing that may have happened at lower levels. A lot of the acceptance testing effort could be reduced if more attention was paid to coverage already achieved at lower levels of automated testing.","Practiced periodically, but not part of the pipeline","Practiced periodically, but not part of the pipeline","Practiced periodically, but not part of the pipeline","Practiced periodically, but not part of the pipeline","Practiced periodically, but not part of the pipeline","Practiced periodically, but not part of the pipeline","Practiced periodically, but not part of the pipeline",Manual testing is used as an augment to other forms of automated testing. Other forms of automated testing are consulted to make sure manual test cases do not repeat effort already spent during automated testing.,"Test data management constitutes activities such as test case design, test data preparation using a combination of data generation script and copying anonymized production data subsets.","Refactoring is encouraged, usually as a task/story distinct from functional development","Immutable, versioned container image e.g. docker, rocket etc.",Automated with zero downtime - rolling or canary,Active passive with MTTR between 2 to 6 hours,Daily,"Deployments can happen anytime during the day, but continue to happen only during specific times of the day due to a lack of approvers, deployment operations personnel etc.","There are no deployment freezes at any time of the year. However, deployment frequency slows during peak periods due to a lack of availability of key personnel (business and operations).","Programmatically provisioned, ephemeral, immutable virtual machine servers.",Private database server with application access restricted to single application - database technology restricted to those currently supportable from an operational perspective.,Is externalized from application configuration. Teams making use of externalized configuration use custom (including homegrown) methods to do so.,"Are externalized from application deployment artifacts. Teams use a consistent approach to toggles, but toggling off functionality still requires knowledge of application internals.",A subset of the release notes are compiled as part of the build pipeline.,API Gateway is used as a single entry point for all consumers. It is used to expose different variations of the same API to different consumers and as a switch to enable zero downtime deployments.,Header-based API versioning is used at all times. Consumers are expected to include a version identifier in the request at all times.,API documentation is produced and kept in sync with implementation at all times. Documentation and implementation are produced from the same source repository.,API standards are published and are stable. New APIs follow the style guide pretty accurately. There is a clear path defined to migrate existing APIs to the new standard.,Architecture decisions are initiated by teams working on a problem. These decisions are reviewed with a central committee to ensure standards are adhered to. Decisions made are captured and persisted in a lightweight manner.,"Architecture decisions are enforced through a combination of documentation, reviews static analysis observations. In addition, some architecture decisions are enforced using a set of fitness functions that are integrated as part of the build.",Event-Driven Microservices,Implementation standardized,Implementation standardized,Implementation standardized,Implementation standardized,Implementation standardized,Implementation standardized,Implementation standardized,Implementation standardized,Implementation standardized,Implementation standardized,Implementation standardized,Implementation standardized,Implementation standardized,Implementation standardized,Implementation standardized,"Practiced periodically, but not part of the pipeline","Practiced periodically, but not part of the pipeline","Practiced periodically, but not part of the pipeline",Data stored at rest is encrypted before it is written to disk. Responsibility for key management is an individual team responsibility.,Data transmitted over the wire is encrypted for all services without exception. Key and certificate management is a team responsibility.,"Both authentication and authorization is a centrally provided capability. The exact methods for authentication and authorization are standardized, but individual teams are responsible for implementation.","Secrets are externalized from application deployment artifacts, with encrypted secrets being stored in a configuration management system."